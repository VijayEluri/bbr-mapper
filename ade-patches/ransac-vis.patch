Index: com/lrf/LRFServerVis.java
===================================================================
--- com/lrf/LRFServerVis.java	(revision 2746)
+++ com/lrf/LRFServerVis.java	(working copy)
@@ -28,6 +28,9 @@
 import javax.swing.JPanel;
 import javax.swing.SwingConstants;
 
+import com.slam.*; // avoid nasty name clash of Line with fully qualified names
+
+
 public class LRFServerVis extends ADEGuiPanel {
 
     private static final long serialVersionUID = 1L;
@@ -74,6 +77,7 @@
     private JCheckBox drawexit = new JCheckBox("Exit", false);
     private JCheckBox drawlines = new JCheckBox("Lines", false);
     private JCheckBox drawoldlines = new JCheckBox("Old lines", false);
+    private JCheckBox drawransac = new JCheckBox("RANSAC", false);
     double[] laserReadings;
     int possibleDoor[] = new int[numVals];
     int totalnumdoors = 0;
@@ -84,6 +88,7 @@
     Line[] oldlines = new Line[numVals]; // to store the previous lines
     double[] X = new double[numVals];
     double[] Y = new double[numVals];
+    com.slam.Line[] ransacLines = null;
 
     public LRFServerVis(ClientAndCallHelper passedClientAndCallHelper) {
         super(passedClientAndCallHelper); // MUST call constructor!
@@ -140,6 +145,7 @@
         optionCheckboxPanel.add(drawexit);
         optionCheckboxPanel.add(drawlines);
         optionCheckboxPanel.add(drawoldlines);
+        optionCheckboxPanel.add(drawransac);
 
         return optionCheckboxPanel;
     }
@@ -173,11 +179,15 @@
             X = detector.X;
             Y = detector.Y;
 
+            Ransac ransac = new Ransac();
+            ransacLines = ransac.findLines(laserReadings);
+
             setLaserVals(laserReadings);
             laserPanel.repaint();
         } catch (Exception ex) {
             System.err.println(this.getClass().getSimpleName()
                     + ":  Could not obtain visualization data! \n" + ex);
+            ex.printStackTrace();
         }
     }
 
@@ -356,10 +366,38 @@
                     }
                 }
             }
+            if(drawransac.isSelected()) {
+                if(ransacLines == null) {
+                    System.out.println("ransacLines == null");
+                    return;
+                }
+                //System.out.format("Have %d ransac lines.\n", ransacLines.length);
+                // Robot's origin is at (xCenter, yCenter);
+                // Graphics size limited by (0, 0), (xSize, ySize).
+                comp2D.setColor(Color.red);
+                for(com.slam.Line line : ransacLines) {
+                    //System.out.format("line: m=%f b=%f (y=mx+b)\n", line.m, line.b);
+                    // Compute line endpoints (may be off-screen -- that's OK)
+                    // in robot's coordinate system.
+                    double x1 = -xCenter * mPerPixel,
+                           y1 = line.m * x1 + line.b,
+                           x2 = xCenter * mPerPixel,
+                           y2 = line.m * x2 + line.b;
+                    //System.out.format("original: x1=%f y1=%f x2=%f y2=%f\n", x1, y1, x2, y2);
+                    // Convert to coord system of canvas (y is reversed...)
+                    double x1s = x1 / mPerPixel + xCenter,
+                           y1s = yCenter - y1 / mPerPixel,
+                           x2s = x2 / mPerPixel + xCenter,
+                           y2s = yCenter - y2 / mPerPixel;
+                    //System.out.format("adjusted: x1s=%f y1s=%f x2s=%f y2s=%f\n", x1s, y1s, x2s, y2s);
+                    // Draw the sucker!
+                    comp2D.drawLine((int)x1s, (int)y1s, (int)x2s, (int)y2s);
+                }
+            }
         }
     }
 
     private static double round(double v, int d) {
         return (double) ((int) (v * Math.pow(10, d))) / Math.pow(10, d);
     }
-}
\ No newline at end of file
+}
